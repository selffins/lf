<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-01-18 Sat 18:28 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Basics.v</title>
<meta name="author" content="selffins" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="custom.css">
</head>
<body>
<div id="content" class="content">
<h1 class="title">Basics.v</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org613264a">1. Summary</a>
<ul>
<li><a href="#org548e196">1.1. Terms</a></li>
</ul>
</li>
<li><a href="#orgba538f9">2. Some basic syntax</a></li>
<li><a href="#org8f7f75e">3. Proof by simplification</a></li>
<li><a href="#org8c7d8eb">4. Proof by rewriting</a></li>
<li><a href="#org098b643">5. Proof by case analysis</a></li>
<li><a href="#orgc62c2cd">6. Optional: More on Notation</a></li>
<li><a href="#org6c76540">7. Optional: Fixpoints and Structural Recursion</a></li>
<li><a href="#org958fe8d">8. Exercises</a>
<ul>
<li><a href="#orgffa3d55">8.1. nandb</a></li>
<li><a href="#orgf69b248">8.2. andb3</a></li>
<li><a href="#org681a3b6">8.3. factorial</a></li>
<li><a href="#org379d5ff">8.4. ltb</a></li>
<li><a href="#org8f1b6b5">8.5. plus​_id​_exercise</a></li>
<li><a href="#org94d8ab7">8.6. mult​_n​_1</a></li>
<li><a href="#orged0ac98">8.7. andb​_true​_elim2</a></li>
<li><a href="#orgb68161c">8.8. decreasing (optional)</a></li>
<li><a href="#org23864fd">8.9. zero​_nbeq​_plus​_1</a></li>
</ul>
</li>
<li><a href="#org4062dbc">9. Exercises (Warmups)</a>
<ul>
<li><a href="#org26690de">9.1. identity​_fn​_applied​_twice</a></li>
<li><a href="#org0528ce6">9.2. negation​_fn​_applied​_twice</a></li>
<li><a href="#orgfc8b674">9.3. andb​_eq​_orb</a></li>
</ul>
</li>
<li><a href="#org94edc64">10. Exercises (&ldquo;Course Late Policies, formalized&rdquo;)</a>
<ul>
<li><a href="#org9d3bd2c">10.1. Background</a></li>
<li><a href="#org5ef2f86">10.2. letter​_comparison​_Eq</a></li>
<li><a href="#orgfc2e28f">10.3. grade​_comparison</a></li>
<li><a href="#orgb943b6f">10.4. lower​_letter​_lowers</a></li>
<li><a href="#org4a91ff9">10.5. lower​_grade</a></li>
<li><a href="#org73384d1">10.6. lower​_grade​_lowers</a></li>
<li><a href="#org0b13040">10.7. no​_penalty​_for​_mostly​_on​_time</a></li>
<li><a href="#orgc3f682b">10.8. graded​_lowered​_once</a></li>
</ul>
</li>
<li><a href="#org3856651">11. Exercises (&ldquo;Binary Numerals&rdquo;)</a>
<ul>
<li><a href="#org622a9d3">11.1. binary</a></li>
</ul>
</li>
<li><a href="#org2d59b39">12. Testing Your Solutions</a></li>
<li><a href="#org276e72d">13. Scores</a></li>
<li><a href="#orgb3cb1b0">14. Questions</a>
<ul>
<li><a href="#org252dff3">14.1. Not a (co-)inductive type? (Propositions are not booleans)</a></li>
<li><a href="#org854cd21">14.2. There&rsquo;s a difference? (Tuple pattern vs multiple patterns in case analysis)</a></li>
<li><a href="#org03f1fab">14.3. What&rsquo;s the difference between <code>rewrite -&gt;</code> and <code>rewrite &lt;-</code>?</a></li>
<li><a href="#orge8ff840">14.4. How do I use the Coq IDE?</a></li>
<li><a href="#org669684a">14.5. Decreasing arguments</a></li>
<li><a href="#orgfacb5d8">14.6. <span class="todo TODO">TODO</span> What is a notation scope?</a></li>
<li><a href="#org68ab96e">14.7. <span class="todo TODO">TODO</span> How do tactics work under the hood?</a></li>
<li><a href="#org47f0bb6">14.8. <span class="todo TODO">TODO</span> How do I change how ProofGeneral looks?</a></li>
<li><a href="#org9b31766">14.9. <span class="todo TODO">TODO</span> <code>bin_to_nat</code>: Helpers needed?</a></li>
</ul>
</li>
<li><a href="#org2617778">15. Metacognition</a>
<ul>
<li><a href="#orgc557275">15.1. Notes structure</a></li>
</ul>
</li>
<li><a href="#orgf3bf712">16. Further knowledge</a>
<ul>
<li><a href="#org2248a87">16.1. About Coq</a></li>
<li><a href="#orgbb4214c">16.2. Some History</a></li>
<li><a href="#org5a88139">16.3. More about CompCert</a></li>
<li><a href="#org2c2c1a3">16.4. <span class="todo TODO">TODO</span> More Coq applications!</a></li>
</ul>
</li>
<li><a href="#org24dc7a5">17. TODOs</a></li>
<li><a href="#org13c5295">18. Next up</a></li>
</ul>
</div>
</div>
<hr />
<p>
<a href="index.html">Homepage</a>
</p>
<div id="outline-container-org613264a" class="outline-2">
<h2 id="org613264a"><span class="section-number-2">1.</span> Summary</h2>
<div class="outline-text-2" id="text-1">
<p>
The chapter introduces Coq&rsquo;s native functional language called Gallina. We also go through proof by simplication, rewriting, and case analysis, and the tactics needed for such proofs. We define natural numbers, booleans; some simple functions on natural numbers and booleans; and prove properties about the functions. We explore Coq&rsquo;s type system.
</p>
</div>
<div id="outline-container-org548e196" class="outline-3">
<h3 id="org548e196"><span class="section-number-3">1.1.</span> Terms</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Coq, interactive theorem prover, functional programming, Gallina, type, expression, <code>Compute</code> command, type definition syntax, type constructors,  enumerated types, function definition syntax, infix notation, pattern matching, booleans, conditionals, parametrized types, tuple types, examples (proof), proof syntax, <code>reflexivity</code> tactic, <code>simpl</code> tactic, assertion syntax, modules, module syntax, natural numbers, nat type, expression evaluation syntax, arrow types, same type parameters idiom, recursive function definition syntax, infix notation options, algebraic data types, propositions, proof by simplification, universal quantifier, proof goals, <code>intro</code> tactic, assumptions, proof context, proposition keywords: <code>{theorem, lemma, fact, example, remark}</code>, proof by rewriting, tactics, <code>rewrite</code> tactic, <code>admitted</code> command, <code>check</code> command, <code>abort</code> command, proof by case analysis, <code>destruct</code> tactic, <code>rewrite</code> with theorem, <code>eqn</code> annotation, intro pattern, bullets, subgoals, notation scope, precedence, associativity, fixpoints, structural recursion, termination requirement, multiple cases sugaring, nested case sugaring, unfolding
</p>
</div>
</div>
</div>
<div id="outline-container-orgba538f9" class="outline-2">
<h2 id="orgba538f9"><span class="section-number-2">2.</span> Some basic syntax</h2>
<div class="outline-text-2" id="text-2">
<p>
Functional programming has code that have no side effects. There is a better connection from programs to mathematical objects.
</p>

<p>
Functions are first-class values. They can be passed as arguments to other functions.
</p>

<p>
Other features include algebraic data types (sum, product types), pattern matching, polymorphic type systems.
</p>

<p>
Coq&rsquo;s native functional language is called <b>Gallina</b>.
</p>

<p>
Coq&rsquo;s built-in features are small. Because we can build almost all the definitions we need. What follows is some small snippets of interest. Refer to the book for more complete snippets.
</p>

<p>
Defining a type.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Inductive</span> <span style="color: #A9DC76;">NAME</span> : <span style="color: #78DCE8;">Type</span> :=
| ...
.
</pre>
</div>

<p>
In this chapter, they first work with enumerated types. We will see tuple types, parametrized types, and so on as well.
</p>

<p>
Defining a function.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Definition</span> <span style="color: #A9DC76;">name</span> arg1 arg2 ... :=
...
.
</pre>
</div>

<p>
Match.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #78DCE8;">match</span> X <span style="color: #78DCE8;">with</span>
| PATTERN -&gt; RESULT
...
<span style="color: #78DCE8;">end</span>.

</pre>
</div>

<p>
There is a command &ldquo;Compute&rdquo; that evaluates expressions.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Compute</span> EXP.
</pre>
</div>

<p>
Examples, or &ldquo;unit tests&rdquo;. And our first proof, and usage of tactics.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Example</span> <span style="color: #A9DC76;">test_orb1</span> (orb true false) = true.
<span style="color: #FF6188;">Proof</span>. <span style="text-decoration: underline;">simpl</span>. <span style="color: #ff0000;">reflexivity</span>. <span style="color: #FF6188;">Qed</span>.
</pre>
</div>

<p>
We are trying to prove an <b>example</b> that  applying orb (logical or) to true and false gives us true. We start a <b>proof</b> and use the tactics <b>simplification</b> and <b>reflexivity</b> to prove it. And then we end, so <b>Qed</b>. There will be discussion of proofs shortly.
</p>

<p>
Infix notation.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Notation</span> <span style="color: #FFD866;">"x &amp;&amp; y"</span> := (andb x y) = true.
</pre>
</div>
<p>
Booleans. Conditionals are like in SML:
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #78DCE8;">if</span> p <span style="color: #78DCE8;">then</span> x <span style="color: #78DCE8;">else</span> y
</pre>
</div>

<p>
An interesting thing is that the guard in the conditional will work with any two-valued type. As in, two-valued types are treated the same as booleans in the sense that the first constructor is treated as True and the other constructor as False. This is useful if we want to make datatypes like &ldquo;blackOrWhite&rdquo; which is either &ldquo;black&rdquo; or &ldquo;white&rdquo;.
</p>

<p>
We can create <b>Modules</b>, we can use them for namespaces.
</p>

<p>
Types are defined with the keyword Inductive.
</p>

<p>
Types can be parametrized - a type constructor can take another element of some type.
</p>

<p>
A type with a single type constructor with multiple parameters can be used to define a tuple type. E.g.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Inductive</span> <span style="color: #A9DC76;">nybble</span> : <span style="color: #78DCE8;">Type</span> :=
| bits (<span style="color: #FCFCFA;">b0 b1 b2 b3</span> : bit).
</pre>
</div>

<p>
So far, the chapter has shown enumerated types, parametrized types, and tuple types. Enumerated types have a finite set of elements. If we want to create an type with an infinite set, like the natural numbers, the type constructor must take itself as a parameter - an inductive definition.
</p>

<p>
The chapter differentiates type constructors and functions - both of them &ldquo;take&rdquo; something as input - however, functions are defined by computation rules, but type constructors are simply representations.
</p>

<p>
Functions are defined with the &ldquo;Definition&rdquo; keyword. However, to declare a recursive function, we must use the Fixpoint keyword.
</p>

<p>
The chapter points out that the simpl tactic has no effect on the proof goals (of the example proofs), only reflexivity does the work. TBD shortly.
</p>

<p>
There is a notational convenience: if two arguments have the same type, they can be written together. E.g.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Fixpoint</span> <span style="color: #A9DC76;">mult</span> (<span style="color: #FCFCFA;">n m</span> : nat) : nat :=
  <span style="color: #78DCE8;">match</span> n <span style="color: #78DCE8;">with</span>
  | O =&gt; O
  | S n' =&gt; plus m (mult n' m)
  <span style="color: #78DCE8;">end</span>.
</pre>
</div>

<p>
Coq does really come with not a lot built in. Natural number comparisons are built in by the user, for example.
</p>

<p>
Propositions are logical claims. So, 1 =? 0 is an expression that evaluates to a boolean, but 1 = 0 is a logical claim that you can (try) to prove.
</p>

<p>
Note that Coq code lines ends with periods.
</p>
</div>
</div>
<div id="outline-container-org8f7f75e" class="outline-2">
<h2 id="org8f7f75e"><span class="section-number-2">3.</span> Proof by simplification</h2>
<div class="outline-text-2" id="text-3">
<p>
So far, all of the proofs were the same: use <code>simpl</code> to simplify both sides, and then use <code>reflexivity</code> to check that both contain identical values.
</p>

<p>
We can use this &ldquo;proof by simplification&rdquo; to establish more interesting properties. <code>0</code> is a neutral element (or identity element) because <code>0 + n</code> reduces to <code>n</code> no matter what <code>n</code> is.
</p>

<p>
We have our first theorem:
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Theorem</span> <span style="color: #A9DC76;">plus_O_n</span> : <span style="color: #78DCE8;">forall</span> <span style="color: #FCFCFA;">n</span> : nat, <span style="color: #AB9DF2; font-weight: bold;">0</span> + n = n.
</pre>
</div>

<p>
We also used an universal quantifier.
</p>

<p>
The chapter notes that the <code>reflexivity</code> tactic is powerful - in the proofs so far, the <code>simpl</code> tactic were actually not required, because <code>reflexivity</code> does some simplification by itself. And, <code>reflexivity</code> actually does <i>more</i> simplification than <code>simpl</code> does! It tries unfolding defined terms, replacing them with their right hand sides. <code>simpl</code> is used when we want an intermediate state, where we need to read and understand the new goal it creates, so that it isn&rsquo;t expanding definitions eagerly like with <code>reflexivity</code> and leave the goal &ldquo;messy&rdquo;.
</p>

<p>
The keywords <code>Example</code>, <code>Theorem</code>, <code>Fact</code>, <code>Lemma</code>, <code>Remark</code> mean &ldquo;pretty much the same thing&rdquo; in Coq. It is a matter of style.
</p>

<p>
Here&rsquo;s the proof for our theorem.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Theorem</span> <span style="color: #A9DC76;">plus_O_n</span> : <span style="color: #78DCE8;">forall</span> <span style="color: #FCFCFA;">n</span> : nat, <span style="color: #AB9DF2; font-weight: bold;">0</span> + n = n.
<span style="color: #FF6188;">Proof</span>.
  <span style="text-decoration: underline;">intros</span> n. <span style="text-decoration: underline;">simpl</span>. <span style="color: #ff0000;">reflexivity</span>.  <span style="color: #FF6188;">Qed</span>.
</pre>
</div>

<p>
<code>intros n</code> is basically like saying &ldquo;Suppose n is a natural number&rdquo; in a proof - it fixes some n and progresses the proof by dealing with the universal quantifier. <code>intros n</code> moves the quantifier in the goal to a <i>context</i> of current assumptions.
</p>

<p>
A tactic is a command that guides the process of checking some claim. It&rsquo;s a move in the proof.
</p>
</div>
</div>
<div id="outline-container-org8c7d8eb" class="outline-2">
<h2 id="org8c7d8eb"><span class="section-number-2">4.</span> Proof by rewriting</h2>
<div class="outline-text-2" id="text-4">
<p>
We have a new kind of theorem - one that uses an implication - it&rsquo;s not a universal property of nunbers, it&rsquo;s a specific one that holds if <code>n=m</code>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Theorem</span> <span style="color: #A9DC76;">plus_id_example</span> : <span style="color: #78DCE8;">forall</span> <span style="color: #FCFCFA;">n m</span>:nat,
  n = m -&gt;
  n + n = m + m.
</pre>
</div>

<p>
To prove this, we need to assume the hypotheses - we can use the <code>intro</code> tactic to get all the needed variables into context.
</p>

<p>
Because <code>n</code> and <code>m</code> are <i>arbitrary</i> numbers, we can&rsquo;t use simplification, which works on expressions (?). We prove this instead by noticing that if we replace <code>n</code> with <code>m</code> in the right hand side, and <code>n = m</code>, then it holds. This is called <b>proof by rewriting</b>. We use the tactic <code>rewrite</code>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Proof</span>.
  <span style="color: #727072;">(* </span><span style="color: #727072;">move both quantifiers into the context:</span><span style="color: #727072;"> *)</span>
  <span style="text-decoration: underline;">intros</span> n m.
  <span style="color: #727072;">(* </span><span style="color: #727072;">move the hypothesis into the context:</span><span style="color: #727072;"> *)</span>
  <span style="text-decoration: underline;">intros</span> H.
  <span style="color: #727072;">(* </span><span style="color: #727072;">rewrite the goal using the hypothesis:</span><span style="color: #727072;"> *)</span>
  <span style="text-decoration: underline;">rewrite</span> -&gt; H.
  <span style="color: #ff0000;">reflexivity</span>.  <span style="color: #FF6188;">Qed</span>.
</pre>
</div>

<p>
Note that we move the quantified variables into the context, but we also move the <b>hypothesis</b> into the context - we assume it, then continue with the goal. The <code>rewrite</code> tactic uses the hypothesis.  <code>rewrite -&gt;</code> means rewriting right to left, which is the default. <code>rewrite &lt;-</code> means rewriting left to right.
</p>

<p>
We can use the <code>rewrite</code> tactic with a theorem instead of a hypothesis from a context. If the theorem has quantified variables, Coq will try to fill in the appropriate values by matching the theorem with the current goal.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Theorem</span> <span style="color: #A9DC76;">mult_n_0_m_0</span> : <span style="color: #78DCE8;">forall</span> <span style="color: #FCFCFA;">p q</span> : nat,
  (p * <span style="color: #AB9DF2; font-weight: bold;">0</span>) + (q * <span style="color: #AB9DF2; font-weight: bold;">0</span>) = <span style="color: #AB9DF2; font-weight: bold;">0</span>.
<span style="color: #FF6188;">Proof</span>.
  <span style="text-decoration: underline;">intros</span> p q.
  <span style="text-decoration: underline;">rewrite</span> &lt;- mult_n_O.
  <span style="text-decoration: underline;">rewrite</span> &lt;- mult_n_O.
  <span style="color: #ff0000;">reflexivity</span>. <span style="color: #FF6188;">Qed</span>.
</pre>
</div>
</div>
</div>
<div id="outline-container-org098b643" class="outline-2">
<h2 id="org098b643"><span class="section-number-2">5.</span> Proof by case analysis</h2>
<div class="outline-text-2" id="text-5">
<p>
Not everything can be proved with simplification and rewriting. Unknown values (those quantified over) can block simplification.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Theorem</span> <span style="color: #A9DC76;">plus_1_neq_0_firsttry</span> : <span style="color: #78DCE8;">forall</span> <span style="color: #FCFCFA;">n</span> : nat,
  (n + <span style="color: #AB9DF2; font-weight: bold;">1</span>) =? <span style="color: #AB9DF2; font-weight: bold;">0</span> = false.
<span style="color: #FF6188;">Proof</span>.
  <span style="text-decoration: underline;">intros</span> n.
  <span style="text-decoration: underline;">simpl</span>.  <span style="color: #727072;">(* </span><span style="color: #727072;">does nothing!</span><span style="color: #727072;"> *)</span>
<span style="background-color: #ff0000;">Abort</span>.
</pre>
</div>

<p>
<code>(n + 1)</code> is a term that can&rsquo;t be simplified, because <code>n</code> is general. So, <code>simpl</code> does nothing.
</p>

<p>
Instead we have to use case analysis - <code>n</code> is either zero, or a successor of some <code>m</code>.
</p>

<p>
If <code>n</code> is zero, then <code>0 + 1</code> is clearly not equal to <code>0</code>. If <code>n</code> is <code>S m</code>, it is enough that it is a successor to say that it is not zero.
</p>

<p>
A case analysis is done in Coq using the <code>destruct</code> tactic. It&rsquo;s called destruct because it considers each case where a value uses a certain constructor - and gives you sub-goals for them.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Theorem</span> <span style="color: #A9DC76;">plus_1_neq_0</span> : <span style="color: #78DCE8;">forall</span> <span style="color: #FCFCFA;">n</span> : nat,
  (n + <span style="color: #AB9DF2; font-weight: bold;">1</span>) =? <span style="color: #AB9DF2; font-weight: bold;">0</span> = false.
<span style="color: #FF6188;">Proof</span>.
  <span style="text-decoration: underline;">intros</span> n. <span style="text-decoration: underline;">destruct</span> n <span style="color: #78DCE8;">as</span> [| n'] eqn:E.
  <span style="color: #FCFCFA; font-weight: bold; text-decoration: underline;">-</span> <span style="color: #ff0000;">reflexivity</span>.
  <span style="color: #FCFCFA; font-weight: bold; text-decoration: underline;">-</span> <span style="color: #ff0000;">reflexivity</span>.   <span style="color: #FF6188;">Qed</span>.
</pre>
</div>

<p>
There is an annotation &ldquo;<code>as [| n']</code>&rdquo; - this tells Coq what variable names to use in each sub-goal. Zero does not have a parameter, so it is empty. The annotation <code>eqn:E</code> tells destruct to give a name to the current case, i.e, either <code>n = 0</code>
or <code>n = S n'</code>. It&rsquo;s optional - you can leave this annotation off and Coq will assign variable names automatically, but that is bad style as the auto-assigned names are usually confusing.
</p>

<p>
There are <code>-</code> signs: they are called bullets, they mark the proofs for the generated subgoals and ensure that a subgoal is complete before trying the next one. It&rsquo;s good practice to mark cases with bullets. Bullets are optional, if omitted, Coq asssumes you do the subgoals in order.
</p>

<p>
You can use different kinds of bullets for subproofs: <code>+</code>, <code>*</code>, and any repetition (e.g. <code>---</code> or <code>***</code>). Sub-proofs can be enclosed in curly braces.
</p>

<p>
The <code>destruct</code> tactic can be used with any inductively defined datatype.
</p>

<p>
I learned a new word: involutive - when an operation is its own inverse.
</p>

<p>
We may notice that many proofs perform case analysis on a variable right after introducing it, as such:
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">intros</span> x y. <span style="text-decoration: underline;">destruct</span> y <span style="color: #78DCE8;">as</span> [|y] eqn:E.
</pre>
</div>

<p>
Here is the shorthand in action. We can simply use the intro pattern after <code>intros</code> instead of using the <code>destruct</code> tactic and then using a intro pattern.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Theorem</span> <span style="color: #A9DC76;">plus_1_neq_0'</span> : <span style="color: #78DCE8;">forall</span> <span style="color: #FCFCFA;">n</span> : nat,
  (n + <span style="color: #AB9DF2; font-weight: bold;">1</span>) =? <span style="color: #AB9DF2; font-weight: bold;">0</span> = false.
<span style="color: #FF6188;">Proof</span>.
  <span style="text-decoration: underline;">intros</span> [|n].
  <span style="color: #FCFCFA; font-weight: bold; text-decoration: underline;">-</span> <span style="color: #ff0000;">reflexivity</span>.
  <span style="color: #FCFCFA; font-weight: bold; text-decoration: underline;">-</span> <span style="color: #ff0000;">reflexivity</span>.  <span style="color: #FF6188;">Qed</span>.
</pre>
</div>

<p>
The downside is that we lose the equation recording the assumption in each subgoal, which we got from the <code>eqn:E</code> annotation.
</p>
</div>
</div>
<div id="outline-container-orgc62c2cd" class="outline-2">
<h2 id="orgc62c2cd"><span class="section-number-2">6.</span> Optional: More on Notation</h2>
<div class="outline-text-2" id="text-6">
<p>
There are some chapters labeled &ldquo;Optional&rdquo;. The authors recommend skimming them.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Notation</span> <span style="color: #FFD866;">"x + y"</span> := (plus x y)
                       (<span style="color: #78DCE8;">at</span> level <span style="color: #AB9DF2; font-weight: bold;">50</span>, <span style="text-decoration: underline;">left</span> associativity)
                       : nat_scope.
<span style="color: #FF6188;">Notation</span> <span style="color: #FFD866;">"x * y"</span> := (mult x y)
                       (<span style="color: #78DCE8;">at</span> level <span style="color: #AB9DF2; font-weight: bold;">40</span>, <span style="text-decoration: underline;">left</span> associativity)
                       : nat_scope.
</pre>
</div>

<p>
For a notation symbol, we can specify the <b>precedence level</b> and <b>associativity</b>. Coq uses precedence levels from 0 to 100, and left, right, or no associativity.
</p>

<p>
Apparently, a notation symbol also has a <b>notation scope</b> (what?).
</p>
</div>
</div>
<div id="outline-container-org6c76540" class="outline-2">
<h2 id="org6c76540"><span class="section-number-2">7.</span> Optional: Fixpoints and Structural Recursion</h2>
<div class="outline-text-2" id="text-7">
<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Fixpoint</span> <span style="color: #A9DC76;">plus'</span> (<span style="color: #FCFCFA;">n</span> : nat) (<span style="color: #FCFCFA;">m</span> : nat) : nat :=
  <span style="color: #78DCE8;">match</span> n <span style="color: #78DCE8;">with</span>
  | O =&gt; m
  | S n' =&gt; S (plus' n' m)
  <span style="color: #78DCE8;">end</span>.
</pre>
</div>

<p>
Here, Coq notes that the function is decreasing in the first argument. We are performing a structural recursion over the argument <code>n</code> - making sure that we only make recursive calls on strictly smaller values of <code>n</code>. This is a proof of termination. Coq <b>demands</b> that some argument of every <code>Fixpoint</code> is decreasing.
</p>

<p>
This is a part of Coq&rsquo;s design - it guarantees that every function will terminate. However, apparently, Coq&rsquo;s automatic analysis of whether inputs decrease isn&rsquo;t very sophisticated, and apparently it is sometimes necessary to write functions in slightly unnatural ways. (What?)
</p>
</div>
</div>
<div id="outline-container-org958fe8d" class="outline-2">
<h2 id="org958fe8d"><span class="section-number-2">8.</span> Exercises</h2>
<div class="outline-text-2" id="text-8">
<p>
There are 20 exercises in total. The following are the exercises in the main text.
</p>
</div>
<div id="outline-container-orgffa3d55" class="outline-3">
<h3 id="orgffa3d55"><span class="section-number-3">8.1.</span> nandb</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Shows how to use <code>simpl</code> and <code>reflexivity</code>.
</p>
</div>
</div>
<div id="outline-container-orgf69b248" class="outline-3">
<h3 id="orgf69b248"><span class="section-number-3">8.2.</span> andb3</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Same as above.
</p>
</div>
</div>
<div id="outline-container-org681a3b6" class="outline-3">
<h3 id="org681a3b6"><span class="section-number-3">8.3.</span> factorial</h3>
<div class="outline-text-3" id="text-8-3">
<p>
Shows how to define a fixpoint function.
</p>
</div>
</div>
<div id="outline-container-org379d5ff" class="outline-3">
<h3 id="org379d5ff"><span class="section-number-3">8.4.</span> ltb</h3>
</div>
<div id="outline-container-org8f1b6b5" class="outline-3">
<h3 id="org8f1b6b5"><span class="section-number-3">8.5.</span> plus​_id​_exercise</h3>
<div class="outline-text-3" id="text-8-5">
<p>
Introducing the <code>intros</code> tactic, for variables and hypotheses.
</p>
</div>
</div>
<div id="outline-container-org94d8ab7" class="outline-3">
<h3 id="org94d8ab7"><span class="section-number-3">8.6.</span> mult​_n​_1</h3>
<div class="outline-text-3" id="text-8-6">
<p>
Shows to use/invoke theorems in proofs using <code>rewrite</code>.
</p>
</div>
</div>
<div id="outline-container-orged0ac98" class="outline-3">
<h3 id="orged0ac98"><span class="section-number-3">8.7.</span> andb​_true​_elim2</h3>
<div class="outline-text-3" id="text-8-7">
<p>
Shows how to use <code>destruct</code> for case analysis. This was a bit tricky before I realized how to step one tactic at a time. You destruct two times. When encountering a contradiction, use it to <code>rewrite</code>.
</p>
</div>
</div>
<div id="outline-container-orgb68161c" class="outline-3">
<h3 id="orgb68161c"><span class="section-number-3">8.8.</span> decreasing (optional)</h3>
<div class="outline-text-3" id="text-8-8">
<p>
The problem was to write a recursive function that terminates on all inputs but gets rejected by Coq&rsquo;s unsophisticated automatic analysis of decreasing arguments.
</p>

<p>
Answer:
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Fixpoint</span> <span style="color: #A9DC76;">summation</span> (<span style="color: #FCFCFA;">i</span> : nat) (<span style="color: #FCFCFA;">n</span> : nat) : nat :=
  <span style="color: #78DCE8;">if</span> i =? n
  <span style="color: #78DCE8;">then</span> n
  <span style="color: #78DCE8;">else</span> i + (summation (i+<span style="color: #AB9DF2; font-weight: bold;">1</span>) n).
</pre>
</div>

<p>
Wow, it&rsquo;s actually interesting how Coq is unable to analyze this simple function as decreasing! They should borrow Why3&rsquo;s <code>variant</code> keyword - <code>n - i</code> is strictly decreasing. In Why3, you&rsquo;d have to include this <code>variant</code> keyword or else Why3 would complain about the function not being proved as terminating.
</p>
</div>
</div>
<div id="outline-container-org23864fd" class="outline-3">
<h3 id="org23864fd"><span class="section-number-3">8.9.</span> zero​_nbeq​_plus​_1</h3>
<div class="outline-text-3" id="text-8-9">
<p>
Straightforward.
</p>
</div>
</div>
</div>
<div id="outline-container-org4062dbc" class="outline-2">
<h2 id="org4062dbc"><span class="section-number-2">9.</span> Exercises (Warmups)</h2>
<div class="outline-text-2" id="text-9">
<p>
These were pretty straightforward uses of rewrites and/or case analysis.
</p>
</div>
<div id="outline-container-org26690de" class="outline-3">
<h3 id="org26690de"><span class="section-number-3">9.1.</span> identity​_fn​_applied​_twice</h3>
</div>
<div id="outline-container-org0528ce6" class="outline-3">
<h3 id="org0528ce6"><span class="section-number-3">9.2.</span> negation​_fn​_applied​_twice</h3>
</div>
<div id="outline-container-orgfc8b674" class="outline-3">
<h3 id="orgfc8b674"><span class="section-number-3">9.3.</span> andb​_eq​_orb</h3>
</div>
</div>
<div id="outline-container-org94edc64" class="outline-2">
<h2 id="org94edc64"><span class="section-number-2">10.</span> Exercises (&ldquo;Course Late Policies, formalized&rdquo;)</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-org9d3bd2c" class="outline-3">
<h3 id="org9d3bd2c"><span class="section-number-3">10.1.</span> Background</h3>
<div class="outline-text-3" id="text-10-1">
<p>
Suppose a course has a grading policy based on late days.
</p>

<p>
A student&rsquo;s letter grade is lowered if they submit too many HW assignments late.
</p>

<p>
We have a <code>letter</code> datatype, modeling the grade. We have a <code>modifier</code> type, which modifies a letter grade.
For example, we can have a <code>Natural A</code>, which is a plain grade of <code>A</code>. There&rsquo;s also <code>Plus A</code>, <code>Minus A</code>.
</p>

<p>
A <code>grade</code> is then just a <code>letter</code> and a <code>modifier</code>. We also create a enumerated type <code>comparison</code>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Inductive</span> <span style="color: #A9DC76;">letter</span> : <span style="color: #78DCE8;">Type</span> :=
  | A | B | C | D | F.
<span style="color: #FF6188;">Inductive</span> <span style="color: #A9DC76;">modifier</span> : <span style="color: #78DCE8;">Type</span> :=
  | Plus | Natural | Minus.
<span style="color: #FF6188;">Inductive</span> <span style="color: #A9DC76;">grade</span> : <span style="color: #78DCE8;">Type</span> :=
  Grade (<span style="color: #FCFCFA;">l</span>:letter) (<span style="color: #FCFCFA;">m</span>:modifier).
<span style="color: #FF6188;">Inductive</span> <span style="color: #A9DC76;">comparison</span> : <span style="color: #78DCE8;">Type</span> :=
  | Eq         <span style="color: #727072;">(* </span><span style="color: #727072;">"equal"</span><span style="color: #727072;"> *)</span>
  | Lt         <span style="color: #727072;">(* </span><span style="color: #727072;">"less than"</span><span style="color: #727072;"> *)</span>
  | Gt.        <span style="color: #727072;">(* </span><span style="color: #727072;">"greater than"</span><span style="color: #727072;"> *)</span>
</pre>
</div>

<p>
This is a straightforward comparison function for letter grades. What&rsquo;s notable though, is the syntactic sugar for two cases at once:
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FFD866;">(** As another shorthand, we can also match one of several</span>
<span style="color: #FFD866;">    possibilites by using [|] in the pattern.  For example the pattern</span>
<span style="color: #FFD866;">    [C , (A | B)] stands for two cases: [C, A] and [C, B]. *)</span>

<span style="color: #FF6188;">Definition</span> <span style="color: #A9DC76;">letter_comparison</span> (<span style="color: #FCFCFA;">l1 l2</span> : letter) : comparison :=
  <span style="color: #78DCE8;">match</span> l1, l2 <span style="color: #78DCE8;">with</span>
  | A, A =&gt; Eq
  | A, _ =&gt; Gt
  | B, A =&gt; Lt
  | B, B =&gt; Eq
  | B, _ =&gt; Gt
  | C, (A | B) =&gt; Lt
  | C, C =&gt; Eq
  | C, _ =&gt; Gt
  | D, (A | B | C) =&gt; Lt
  | D, D =&gt; Eq
  | D, _ =&gt; Gt
  | F, (A | B | C | D) =&gt; Lt
  | F, F =&gt; Eq
  <span style="color: #78DCE8;">end</span>.
</pre>
</div>

<p>
And we also have a modifier comparison.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Definition</span> <span style="color: #A9DC76;">modifier_comparison</span> (<span style="color: #FCFCFA;">m1 m2</span> : modifier) : comparison :=
  <span style="color: #78DCE8;">match</span> m1, m2 <span style="color: #78DCE8;">with</span>
  | Plus, Plus =&gt; Eq
  | Plus, _ =&gt; Gt
  | Natural, Plus =&gt; Lt
  | Natural, Natural =&gt; Eq
  | Natural, _ =&gt; Gt
  | Minus, (Plus | Natural) =&gt; Lt
  | Minus, Minus =&gt; Eq
  <span style="color: #78DCE8;">end</span>.
</pre>
</div>

<p>
We define <code>lower_letter</code> - a function that lowers a letter grade. It&rsquo;s just simple pattern matching.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Definition</span> <span style="color: #A9DC76;">lower_letter</span> (<span style="color: #FCFCFA;">l</span> : letter) : letter :=
  <span style="color: #78DCE8;">match</span> l <span style="color: #78DCE8;">with</span>
  | A =&gt; B
  | B =&gt; C
  | C =&gt; D
  | D =&gt; F
  | F =&gt; F  <span style="color: #727072;">(* </span><span style="color: #727072;">Can't go lower than [F]!</span><span style="color: #727072;"> *)</span>
  <span style="color: #78DCE8;">end</span>.
</pre>
</div>
</div>
</div>
<div id="outline-container-org5ef2f86" class="outline-3">
<h3 id="org5ef2f86"><span class="section-number-3">10.2.</span> letter​_comparison​_Eq</h3>
<div class="outline-text-3" id="text-10-2">
<p>
Destructing a letter gives you five possible options.
</p>
</div>
</div>
<div id="outline-container-orgfc2e28f" class="outline-3">
<h3 id="orgfc2e28f"><span class="section-number-3">10.3.</span> grade​_comparison</h3>
<div class="outline-text-3" id="text-10-3">
<p>
We define a comparison function for grades. The resulting ordering is called &ldquo;lexicographic ordering&rdquo;.
</p>

<p>
A hint is given - match <code>g1</code> and <code>g2</code> simultaneously but don&rsquo;t &ldquo;enumerate all the cases&rdquo; &#x2013; do case analysis on <code>letter​_comparison</code> call.
</p>

<p>
Interesting things: <code>reflexivity</code> should quickly prove a &ldquo;unit test&rdquo; of a function. Nested <code>match</code> expression &#x2013; the inner one doesn&rsquo;t end with a dot. It seems periods close a full term.
</p>
</div>
</div>
<div id="outline-container-orgb943b6f" class="outline-3">
<h3 id="orgb943b6f"><span class="section-number-3">10.4.</span> lower​_letter​_lowers</h3>
</div>
<div id="outline-container-org4a91ff9" class="outline-3">
<h3 id="org4a91ff9"><span class="section-number-3">10.5.</span> lower​_grade</h3>
</div>
<div id="outline-container-org73384d1" class="outline-3">
<h3 id="org73384d1"><span class="section-number-3">10.6.</span> lower​_grade​_lowers</h3>
<div class="outline-text-3" id="text-10-6">
<p>
This was the most fun proof so far! There was a lot of strategic destructs, simplifications, and rewrites. We also used previous theorems.
</p>
</div>
</div>
<div id="outline-container-org0b13040" class="outline-3">
<h3 id="org0b13040"><span class="section-number-3">10.7.</span> no​_penalty​_for​_mostly​_on​_time</h3>
<div class="outline-text-3" id="text-10-7">
<p>
This &ldquo;unfolding&rdquo; technique is <b>quite</b> important.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FFD866;">(** Sometimes it is useful to be able to "unfold" a definition to be</span>
<span style="color: #FFD866;">    able to make progress on a proof.  Soon, we will see how to do this</span>
<span style="color: #FFD866;">    in a much simpler way automatically, but for now, it is easy to prove</span>
<span style="color: #FFD866;">    that a use of any definition like [apply_late_policy] is equal to its</span>
<span style="color: #FFD866;">    right hand side just by using reflexivity.</span>

<span style="color: #FFD866;">    This result is useful because it allows us to use [rewrite] to</span>
<span style="color: #FFD866;">    expose the internals of the definition. *)</span>
<span style="color: #FF6188;">Theorem</span> <span style="color: #A9DC76;">apply_late_policy_unfold</span> :
  <span style="color: #78DCE8;">forall</span> (<span style="color: #FCFCFA;">late_days</span> : nat) (<span style="color: #FCFCFA;">g</span> : grade),
    (apply_late_policy late_days g)
    =
    (<span style="color: #78DCE8;">if</span> late_days &lt;? <span style="color: #AB9DF2; font-weight: bold;">9</span> <span style="color: #78DCE8;">then</span> g  <span style="color: #78DCE8;">else</span>
       <span style="color: #78DCE8;">if</span> late_days &lt;? <span style="color: #AB9DF2; font-weight: bold;">17</span> <span style="color: #78DCE8;">then</span> lower_grade g
       <span style="color: #78DCE8;">else</span> <span style="color: #78DCE8;">if</span> late_days &lt;? <span style="color: #AB9DF2; font-weight: bold;">21</span> <span style="color: #78DCE8;">then</span> lower_grade (lower_grade g)
            <span style="color: #78DCE8;">else</span> lower_grade (lower_grade (lower_grade g))).
<span style="color: #FF6188;">Proof</span>.
  <span style="text-decoration: underline;">intros</span>. <span style="color: #ff0000;">reflexivity</span>.
<span style="color: #FF6188;">Qed</span>.

</pre>
</div>
</div>
</div>
<div id="outline-container-orgc3f682b" class="outline-3">
<h3 id="orgc3f682b"><span class="section-number-3">10.8.</span> graded​_lowered​_once</h3>
<div class="outline-text-3" id="text-10-8">
<p>
Same thing as above.
</p>
</div>
</div>
</div>
<div id="outline-container-org3856651" class="outline-2">
<h2 id="org3856651"><span class="section-number-2">11.</span> Exercises (&ldquo;Binary Numerals&rdquo;)</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-org622a9d3" class="outline-3">
<h3 id="org622a9d3"><span class="section-number-3">11.1.</span> binary</h3>
<div class="outline-text-3" id="text-11-1">
<p>
We are given this background:
</p>

<div class="org-src-container">
<pre class="src src-coq">
<span style="color: #FFD866;">(** **** </span><span style="color: #FFD866;">Exercise: 3 stars, standard (binary</span><span style="color: #FFD866;">)</span>

<span style="color: #FFD866;">    We can generalize our unary representation of natural numbers to</span>
<span style="color: #FFD866;">    the more efficient binary representation by treating a binary</span>
<span style="color: #FFD866;">    number as a sequence of constructors [B0] and [B1] (representing 0s</span>
<span style="color: #FFD866;">    and 1s), terminated by a [Z]. For comparison, in the unary</span>
<span style="color: #FFD866;">    representation, a number is a sequence of [S] constructors terminated</span>
<span style="color: #FFD866;">    by an [O].</span>

<span style="color: #FFD866;">    For example:</span>

<span style="color: #FFD866;">        decimal               binary                          unary</span>
<span style="color: #FFD866;">           0                       Z                              O</span>
<span style="color: #FFD866;">           1                    B1 Z                            S O</span>
<span style="color: #FFD866;">           2                B0 (B1 Z)                        S (S O)</span>
<span style="color: #FFD866;">           3                B1 (B1 Z)                     S (S (S O))</span>
<span style="color: #FFD866;">           4            B0 (B0 (B1 Z))                 S (S (S (S O)))</span>
<span style="color: #FFD866;">           5            B1 (B0 (B1 Z))              S (S (S (S (S O))))</span>
<span style="color: #FFD866;">           6            B0 (B1 (B1 Z))           S (S (S (S (S (S O)))))</span>
<span style="color: #FFD866;">           7            B1 (B1 (B1 Z))        S (S (S (S (S (S (S O))))))</span>
<span style="color: #FFD866;">           8        B0 (B0 (B0 (B1 Z)))    S (S (S (S (S (S (S (S O)))))))</span>

<span style="color: #FFD866;">    Note that the low-order bit is on the left and the high-order bit</span>
<span style="color: #FFD866;">    is on the right -- the opposite of the way binary numbers are</span>
<span style="color: #FFD866;">    usually written.  This choice makes them easier to manipulate. *)</span>
</pre>
</div>

<p>
The task was to define an increment function <code>incr</code> and a conversion function <code>bin_to_nat</code>.
</p>

<p>
For <code>bin_to_nat</code>, I had to define <code>pow</code> and use a helper function <code>bin_to_nat'</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-org2d59b39" class="outline-2">
<h2 id="org2d59b39"><span class="section-number-2">12.</span> Testing Your Solutions</h2>
<div class="outline-text-2" id="text-12">
<p>
The test file for this chapter is <code>BasicsTest.v</code>. To run it, make sure you have saved <code>Basics.v</code> to disk. Then first run <code>coqc -Q . LF Basics.v</code> and then run <code>coqc -Q . LF BasicsTest.v</code>; or, if you have make installed, you can run <code>make BasicsTest.vo</code>. (Make sure you do this in a directory that also contains a file named <code>_CoqProject</code> containing the single line <code>-Q . LF.</code>)
</p>

<p>
The output is useful:
</p>
<ol class="org-ol">
<li>The actual output from the Coq file itself.</li>
<li>For each exercise, its point value, whether the type is ok, what assumptions it relies on.</li>
<li>Maximum number of points in standard and advanced versions of the assignment.</li>
<li>A list of allowed axioms.</li>
<li>A summary of whether you have solved each exercise.</li>
</ol>

<p>
Manually graded exercises show up but the test script doesn&rsquo;t give a lot of information.
</p>
</div>
</div>
<div id="outline-container-org276e72d" class="outline-2">
<h2 id="org276e72d"><span class="section-number-2">13.</span> Scores</h2>
<div class="outline-text-2" id="text-13">
<p>
<a href="exercises/basics-results.html">
The output from the grade script is here.</a>
</p>
</div>
</div>
<div id="outline-container-orgb3cb1b0" class="outline-2">
<h2 id="orgb3cb1b0"><span class="section-number-2">14.</span> Questions</h2>
<div class="outline-text-2" id="text-14">
</div>
<div id="outline-container-org252dff3" class="outline-3">
<h3 id="org252dff3"><span class="section-number-3">14.1.</span> Not a (co-)inductive type? (Propositions are not booleans)</h3>
<div class="outline-text-3" id="text-14-1">
<p>
When doing the factorial exercise, I defined factorial as such:
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Fixpoint</span> <span style="color: #A9DC76;">factorial</span> (<span style="color: #FCFCFA;">n</span>:nat) : nat :=
  <span style="color: #78DCE8;">match</span> n <span style="color: #78DCE8;">with</span>
  | <span style="color: #AB9DF2; font-weight: bold;">0</span> =&gt; <span style="color: #AB9DF2; font-weight: bold;">1</span>
  | S n =&gt; <span style="color: #78DCE8;">if</span> (n &gt; <span style="color: #AB9DF2; font-weight: bold;">0</span>) <span style="color: #78DCE8;">then</span> n * factorial(n-<span style="color: #AB9DF2; font-weight: bold;">1</span>) <span style="color: #78DCE8;">else</span> <span style="color: #AB9DF2; font-weight: bold;">1</span>
  <span style="color: #78DCE8;">end</span>.
</pre>
</div>

<p>
I needed the conditional so that it terminates for negative inputs. Well, I didn&rsquo;t need to do this, because 1) n is a natural number, not an integer 2) n &gt; 0 always because 0 is already matched.
</p>

<p>
Anyway, with this conditional, I get the error:
</p>

<div class="org-src-container">
<pre class="src src-bash">Error: The term <span style="color: #FFD866;">"n0 &gt; 0"</span> has type <span style="color: #FFD866;">"Prop"</span> which is not a <span style="color: #AB9DF2;">(</span>co-<span style="color: #AB9DF2;">)</span>inductive type.
</pre>
</div>

<p>
Why is this happening? I am assuming that <code>Prop</code> is the proposition type, are propositions different from booleans? Why is the comparison typed as a <code>Prop</code> instead of a boolean?
</p>

<p>
<span class="underline">SOLVED</span>:
</p>

<p>
Yes, I read later in the chapter that propositions are different from booleans. For example, <code>1 = 0</code> is a <b>logical claim</b>, a proposition you can <b>prove</b>, but <code>1 =? 0</code> (<code>?</code> is boolean equality) is an expression that evaluates to a boolean. So, <code>n0 &gt; 0</code> is type <code>Prop</code> - we need to use a less than operator that is in the boolean world.
</p>
</div>
</div>
<div id="outline-container-org854cd21" class="outline-3">
<h3 id="org854cd21"><span class="section-number-3">14.2.</span> There&rsquo;s a difference? (Tuple pattern vs multiple patterns in case analysis)</h3>
<div class="outline-text-3" id="text-14-2">
<p>
Apparently, there is a difference between the patterns <code>a, b</code> and <code>(a, b)</code>!
</p>

<p>
These don&rsquo;t work:
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #78DCE8;">match</span> leb n m, eqb n m <span style="color: #78DCE8;">with</span>
  | true, false =&gt; true
  | _ =&gt; false
<span style="color: #78DCE8;">end</span>.
</pre>
</div>

<p>
The compiler will complain that it expects two patterns for the second case.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #78DCE8;">match</span> (leb n m, eqb n m) <span style="color: #78DCE8;">with</span>
  | true, false =&gt; true
  | _ =&gt; false
<span style="color: #78DCE8;">end</span>.
</pre>
</div>

<p>
Here, the compiler will complain that it expects one pattern for the first case.
</p>

<p>
However, these work:
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #78DCE8;">match</span> leb n m, eqb n m <span style="color: #78DCE8;">with</span>
  | true, false =&gt; true
  | _, _ =&gt; false
<span style="color: #78DCE8;">end</span>.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #78DCE8;">match</span> (leb n m, eqb n m) <span style="color: #78DCE8;">with</span>
  | (true, false) =&gt; true
  | _ =&gt; false
<span style="color: #78DCE8;">end</span>.
</pre>
</div>

<p>
Why is there a difference, or what is the difference?
</p>

<p>
<span class="underline">ANSWERED</span>:
</p>

<p>
Here&rsquo;s the relevant passage.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FFD866;">(** This is simply a convenient abbreviation for nested pattern</span>
<span style="color: #FFD866;">    matching.  For example, the match expression on the left below is</span>
<span style="color: #FFD866;">    just shorthand for the lower-level "expanded version" shown on the</span>
<span style="color: #FFD866;">    right: **)</span>

<span style="color: #78DCE8;">match</span> l1, l2 <span style="color: #78DCE8;">with</span>
| A, A =&gt; Eq
| A, _ =&gt; Gt
<span style="color: #78DCE8;">end</span>

<span style="color: #78DCE8;">match</span> l1 <span style="color: #78DCE8;">with</span>
| A =&gt; <span style="color: #78DCE8;">match</span> l2 <span style="color: #78DCE8;">with</span>
       | A =&gt; Eq
       | _ =&gt; Gt
       <span style="color: #78DCE8;">end</span>
<span style="color: #78DCE8;">end</span>
</pre>
</div>

<p>
This means that one (tuples) is an actual type/pattern, while the comma-on-its-own pattern is syntactic sugar for nested matches.
</p>

<p>
There&rsquo;s still a small question: What does it matter? Apparently in Why3 / automated theorem prover, the code structure matters, because the prover can get confused&#x2026;
</p>

<p>
Does it matter that we use a tuple or nested matches? Maybe it has to do something with <code>simpl</code> behavior.
</p>
</div>
</div>
<div id="outline-container-org03f1fab" class="outline-3">
<h3 id="org03f1fab"><span class="section-number-3">14.3.</span> What&rsquo;s the difference between <code>rewrite -&gt;</code> and <code>rewrite &lt;-</code>?</h3>
<div class="outline-text-3" id="text-14-3">
<p>
Apparently <code>rewrite -&gt;</code> is rewriting from &ldquo;left to right&rdquo; while <code>rewrite &lt;-</code> is rewriting from &ldquo;right to left&rdquo;.
</p>

<p>
What is the difference? When does it matter and what&rsquo;s an example of when it matters?
</p>

<p>
<span class="underline">ANSWERED</span>:
</p>

<p>
You can try it out on proofs.
</p>
</div>
</div>
<div id="outline-container-orge8ff840" class="outline-3">
<h3 id="orge8ff840"><span class="section-number-3">14.4.</span> How do I use the Coq IDE?</h3>
<div class="outline-text-3" id="text-14-4">
<p>
I want to see what the current goal looks like, at an intermediate proof step. I don&rsquo;t know how to do that.
</p>

<p>
<span class="underline">ANSWERED</span>:
</p>

<p>
It&rsquo;s pretty simple. Use the arrows to step through each line. The screen on the right shows you the current goal.
</p>

<p>
Oh, and the UI is atrociously bright, so I&rsquo;ve switched to ProofGeneral in emacs. It also allows me to have my notes on a buffer to the side.
</p>

<p>
For ProofGeneral, the keybindings  <code>C-c C-n</code>, <code>C-c C-u</code>, <code>C-c C-RET</code> are what matters most.
</p>
</div>
</div>
<div id="outline-container-org669684a" class="outline-3">
<h3 id="org669684a"><span class="section-number-3">14.5.</span> Decreasing arguments</h3>
<div class="outline-text-3" id="text-14-5">
<p>
Coq demands that at least one argument in a <code>Fixpoint</code> definition of a function be strictly decreasing. This ensures that all functions terminate. How does Coq do this? And why does the author say that Coq&rsquo;s way of doing this is unsophisticated, and that it is &ldquo;sometimes necessary to write functions in slightly unnatural ways?&rdquo;
</p>

<p>
<span class="underline">ANSWERED</span>:
</p>

<p>
OK, I&rsquo;ve defined a function <code>summation</code> that Coq doesn&rsquo;t detect as terminating. This is because the argument <code>i</code> is increasing and the other argument <code>n</code> is constant. We know it terminates because <code>n-i</code> strictly decreases and reaches 0. This seems annoying &#x2013; can&rsquo;t we avoid having to design code such that every argument must be decreasing?
</p>
</div>
</div>
<div id="outline-container-orgfacb5d8" class="outline-3">
<h3 id="orgfacb5d8"><span class="section-number-3">14.6.</span> <span class="todo TODO">TODO</span> What is a notation scope?</h3>
<div class="outline-text-3" id="text-14-6">
<p>
A notation (infix operator) has precedence, associativity, and a notation scope. What&rsquo;s a notation scope? This isn&rsquo;t too important (it&rsquo;s just for infix operators in Coq!), but the chapter talks about it but never clarifies or defines what a notation scope is.
</p>
</div>
</div>
<div id="outline-container-org68ab96e" class="outline-3">
<h3 id="org68ab96e"><span class="section-number-3">14.7.</span> <span class="todo TODO">TODO</span> How do tactics work under the hood?</h3>
<div class="outline-text-3" id="text-14-7">
<p>
The chapter explains how tactics are used. And I got a lot of practice with tactics. But what is actually happening when I use a tactic? Can someone explain the parts of an interactive theorem prover?
</p>
</div>
</div>
<div id="outline-container-org47f0bb6" class="outline-3">
<h3 id="org47f0bb6"><span class="section-number-3">14.8.</span> <span class="todo TODO">TODO</span> How do I change how ProofGeneral looks?</h3>
<div class="outline-text-3" id="text-14-8">
<p>
The underlined buffer thingy is atrocious.
</p>
</div>
</div>
<div id="outline-container-org9b31766" class="outline-3">
<h3 id="org9b31766"><span class="section-number-3">14.9.</span> <span class="todo TODO">TODO</span> <code>bin_to_nat</code>: Helpers needed?</h3>
<div class="outline-text-3" id="text-14-9">
<p>
For <code>bin_to_nat</code>, I had to define <code>pow</code> and use a helper function <code>bin_to_nat'</code>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="color: #FF6188;">Definition</span> <span style="color: #A9DC76;">bin_to_nat</span> (<span style="color: #FCFCFA;">m</span> : bin) : nat :=
  bin_to_nat' m O.
</pre>
</div>

<p>
The wording of the question makes me feel like it can be done only one <code>Fixpoint bin_to_nat</code>.  I don&rsquo;t know if that&rsquo;s possible. I don&rsquo;t think so, personally.
</p>
</div>
</div>
</div>
<div id="outline-container-org2617778" class="outline-2">
<h2 id="org2617778"><span class="section-number-2">15.</span> Metacognition</h2>
<div class="outline-text-2" id="text-15">
<p>
I think that the book so far is really fun. I also like the way I am making notes. I love emacs. There are a lot of exercises.
</p>
</div>
<div id="outline-container-orgc557275" class="outline-3">
<h3 id="orgc557275"><span class="section-number-3">15.1.</span> Notes structure</h3>
<div class="outline-text-3" id="text-15-1">
<p>
I am gonna do this template for notes in the future:
</p>

<ul class="org-ul">
<li>Summary</li>
<li>Section 1 (actual notes)</li>
<li>&#x2026;</li>
<li>Optional sections</li>
<li>Exercises</li>
<li>Questions</li>
<li>Reflections</li>
<li>Further knowledge</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf3bf712" class="outline-2">
<h2 id="orgf3bf712"><span class="section-number-2">16.</span> Further knowledge</h2>
<div class="outline-text-2" id="text-16">
</div>
<div id="outline-container-org2248a87" class="outline-3">
<h3 id="org2248a87"><span class="section-number-3">16.1.</span> About Coq</h3>
<div class="outline-text-3" id="text-16-1">
<p>
Adapted from <a href="https://en.wikipedia.org/wiki/Coq_(software)">https://en.wikipedia.org/wiki/Coq_(software)</a>
</p>

<p>
Coq is a <b>interactive theorem prover</b> released in 1989. Coq works within the theory of the <b>calculus of inductive constructions</b> (what?). Coq is not an automated theorem prover.
</p>

<p>
Coq has a specification language (what?) called <b>Gallina</b>. Programs in Gallina abide by the <b>weak normalization</b> (what?) property, implying that they always terminate. This avoids the <b>halting problem</b>.
</p>
</div>
</div>
<div id="outline-container-orgbb4214c" class="outline-3">
<h3 id="orgbb4214c"><span class="section-number-3">16.2.</span> Some History</h3>
<div class="outline-text-3" id="text-16-2">
<p>
The development of Coq has been supported since 1984 by French Institute for Research in Computer Science and Automation (INRIA), initiated by Thierry Coquand and  Gérard Huet.
</p>

<p>
The Association for Computing Machinery awarded Thierry Coquand, Gérard Huet, Christine Paulin-Mohring, Bruno Barras, Jean-Christophe Filliâtre, Hugo Herbelin, Chetan Murthy, Yves Bertot, and Pierre Castéran with the 2013 ACM Software System Award for Coq.
</p>

<p>
<b>Coq</b> is rooster in French, and comes from the French tradition of naming research development tools after animals. It is also a reference to Coquand&rsquo;s name and CoC (Calculus of Constructions).
However, the Coq community has voted to change the name to <b>&ldquo;The Rocq Prover&rdquo;</b> in coming months.
</p>

<p>
<b>Gallina</b> means hen in Latin, Spanish, Italian and Catalan.
</p>

<p>
Coq was used by Georges Gonthier of Microsoft Research and Benjamin Wenrer of INRIA to create a <b>surveyable proof</b> (what?) of the four color theorem in 2002.
</p>

<p>
Notable applications include <b>CompCert</b>, a optimizing compiler for almost all of the C programming language which is programmed and proven correct in Coq, <b>Feit-Thompson Theorem</b> (some substantial group theory thing), and the <b>Fundamental group</b> of the circle.
</p>

<p>
In 2024, Coq proved the value of the 5-state Busy beaver. The value of the 5-state winning busy beaver was discovered by Heiner Marxen and Jürgen Buntrock back in 1989.
</p>

<p>
<b>A recent effort within this field is making these tools use artificial intelligence to automate the formalization of ordinary mathematics.</b>
</p>
</div>
</div>
<div id="outline-container-org5a88139" class="outline-3">
<h3 id="org5a88139"><span class="section-number-3">16.3.</span> More about CompCert</h3>
<div class="outline-text-3" id="text-16-3">
<p>
Adapted from <a href="https://www.seas.upenn.edu/~cis5000/current/lectures/cis5000-lec01.pdf">https://www.seas.upenn.edu/~cis5000/current/lectures/cis5000-lec01.pdf</a>, slide 20.
</p>

<p>
CompCert is by Xavier Leroy at INRIA. The project was started on 2010.
</p>

<p>
A 2011 PLDI paper studied bugs in C compilers. They generaqted random test cases, put them in source programs, and then compiled it with GCC, LLVM, and 8 other C compilers. There were 325 bugs in total (LLVM: 202, GCC: 79).
</p>

<p>
CompCert had &lt;10 bugs then (this was when CompCert was still unverified).
</p>

<p>
After CompCert was verified, they concluded that:
</p>

<blockquote>
<p>
The striking thing about our CompCert results is that the
middle-end bugs we found in all other compilers are
absent. As of early 2011, the under-development version of
CompCert is the only compiler we have tested for which
Csmith cannot find wrong-code errors. This is not for lack
of trying: we have devoted about six CPU-years to the task.
The apparent unbreakability of CompCert supports a
strong argument that developing compiler optimizations
within a proof framework, where safety checks are explicit
and machine-checked, has tangible benefits for compiler
users.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org2c2c1a3" class="outline-3">
<h3 id="org2c2c1a3"><span class="section-number-3">16.4.</span> <span class="todo TODO">TODO</span> More Coq applications!</h3>
<div class="outline-text-3" id="text-16-4">

<div id="org39f596c" class="figure">
<p><img src="./img/coq-applications.png" alt="coq-applications.png" />
</p>
<p><span class="figure-number">Figure 1: </span>There&rsquo;s a fair bit of work around Coq in academia and industry.  Taken from UPenn CIS5000.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org24dc7a5" class="outline-2">
<h2 id="org24dc7a5"><span class="section-number-2">17.</span> TODOs</h2>
<div class="outline-text-2" id="text-17">
</div>
<div id="outline-container-org483f25c" class="outline-4">
<h4 id="org483f25c">do exercises</h4>
</div>
<div id="outline-container-orgb49d472" class="outline-4">
<h4 id="orgb49d472"><span class="todo TODO">TODO</span> add footnotes and bibliography</h4>
</div>
<div id="outline-container-orga06b79b" class="outline-4">
<h4 id="orga06b79b"><span class="todo TODO">TODO</span> proof-read</h4>
</div>
<div id="outline-container-org99a797a" class="outline-4">
<h4 id="org99a797a"><span class="todo TODO">TODO</span> Explain the More Coq Applications image.</h4>
</div>
<div id="outline-container-org8ca729f" class="outline-4">
<h4 id="org8ca729f"><span class="todo TODO">TODO</span> add the Further Knowledge section to its own file. We&rsquo;ll keep a copy here though.</h4>
</div>
</div>
<div id="outline-container-org13c5295" class="outline-2">
<h2 id="org13c5295"><span class="section-number-2">18.</span> Next up</h2>
<div class="outline-text-2" id="text-18">
<p>
<a href="sf-notes-1.html">Proof by induction.</a>
</p>
<hr />
<p>
<a href="sf-notes.html">Back to Top</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: selffins</p>
<p class="date">Created: 2025-01-18 Sat 18:28</p>
</div>
</body>
</html>
